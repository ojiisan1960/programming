     1                                  ; Source name     : CHARSIN.ASM
     2                                  ; Executable name : CHARSIN
     3                                  ; Version         : 1.0
     4                                  ; Created date    : 11/21/1999
     5                                  ; Last update     : 11/30/1999
     6                                  ; Author          : Jeff Duntemann
     7                                  ; Description     : A data input demo for Linux, using NASM 0.98
     8                                  ;
     9                                  ; Build using these commands:
    10                                  ;  nasm -f elf charsin.asm
    11                                  ;  gcc charsin.o -o charsin
    12                                  ;
    13                                  [SECTION .text]         ; Section containing code
    14                                  extern stdin            ; Standard file variable for input
    15                                  extern fgets
    16                                  extern printf
    17                                  extern scanf
    18                                  global main             ; Required so linker can find entry point
    19                                  main:
    20 00000000 55                          push ebp            ; Set up stack frame for debugger
    21 00000001 89E5                        mov ebp,esp
    22 00000003 53                          push ebx            ; Program must preserve ebp, ebx, esi, & edi
    23 00000004 56                          push esi
    24 00000005 57                          push edi
    25                                      ;;; Everything before this is boilerplate; use it for all ordinary apps!
    26                                      ;; First, an example of safely limited string input using fgets. Unlike
    27                                      ;; gets, which does not allow limiting the number of chars entered, fgets
    28                                      ;; lets you specify a maximum number. However, you must also specify a
    29                                      ;; file (hence the 'f' in 'fgets') so we must push the stdin handle.
    30 00000006 68[00000000]            push dword sprompt  ; Push address of the string input prompt string
    31 0000000B E8(00000000)            call printf         ; Display it
    32 00000010 81C404000000            add esp,4           ; Clean up stack for 1 arg
    33 00000016 FF35[00000000]          push dword [stdin]  ; Push predefined file handle for standard input
    34 0000001C 6848000000              push dword 72       ; Accept no more than 72 characters from keybd.
    35 00000021 68[04000000]            push dword instring ; Push address of buffer for entered characters
    36 00000026 E8(00000000)            call fgets          ; Call fgets
    37 0000002B 81C40C000000            add esp,12          ; 3 args X 4 bytes = 12 for stack cleanup
    38 00000031 68[04000000]            push dword instring ; Push address of entered string data buffer
    39 00000036 68[59000000]            push dword sshow    ; Push address of the string display prompt
    40 0000003B E8(00000000)            call printf         ; Call printf
    41 00000040 81C408000000            add esp,8           ; Clean up the stack
    42                                  ;; Next, we'll use scanf to enter numeric data. This is easier, because
    43                                  ;; unlike strings, integers can only be so big and hence are self-
    44                                  ;; limiting.
    45 00000046 68[27000000]            push dword iprompt  ; Push address of the integer input prompt
    46 0000004B E8(00000000)            call printf         ; Display it
    47 00000050 81C404000000            add esp,4           ; Clean up the stack
    48 00000056 68[00000000]            push dword intval   ; Push the address of the integer buffer
    49 0000005B 68[56000000]            push dword iformat  ; Push the address of the integer format string
    50 00000060 E8(00000000)            call scanf          ; Call scanf to enter numeric data
    51 00000065 81C408000000            add esp,8           ; Clean up the stack
    52 0000006B FF35[00000000]          push dword [intval] ; Push integer value to display
    53 00000071 68[79000000]            push dword ishow    ; Push base string
    54 00000076 E8(00000000)            call printf         ; Call printf to convert & display the integer
    55 0000007B 81C408000000            add esp,8           ; Clean up the stack
    56                                  ;;; Everything after this is boilerplate; use it for all ordinary apps!
    57 00000081 5F                      pop edi             ; Restore saved registers
    58 00000082 5E                      pop esi
    59 00000083 5B                      pop ebx
    60 00000084 89EC                    mov esp,ebp         ; Destroy stack frame before returning
    61 00000086 5D                      pop ebp
    62 00000087 C3                      ret                 ; Return control to Linux
    63                                  [SECTION .data]         ; Section containing initialized data
    64 00000000 456E74657220737472-     sprompt db 'Enter string data, followed by Enter: ',0
    65 00000009 696E6720646174612C-
    66 00000012 20666F6C6C6F776564-
    67 0000001B 20627920456E746572-
    68 00000024 3A2000             
    69 00000027 456E74657220616E20-     iprompt db 'Enter an integer value, followed by Enter:    ',0
    70 00000030 696E74656765722076-
    71 00000039 616C75652C20666F6C-
    72 00000042 6C6F77656420627920-
    73 0000004B 456E7465723A202020-
    74 00000054 2000               
    75 00000056 256400                  iformat db '%d',0
    76 00000059 54686520737472696E-     sshow db 'The string you entered was: %s',10,0
    77 00000062 6720796F7520656E74-
    78 0000006B 65726564207761733A-
    79 00000074 2025730A00         
    80 00000079 54686520696E746567-     ishow db 'The integer value you entered was: %5d',10,0
    81 00000082 65722076616C756520-
    82 0000008B 796F7520656E746572-
    83 00000094 6564207761733A2025-
    84 0000009D 35640A00           
    85                                  [SECTION .bss]          ; Section containing uninitialized data
    86 00000000 <res 00000004>          intval   resd 1         ; Reserve one uninitialized double word
    87 00000004 <res 00000080>          instring resb 128       ; Reserve 128 bytes for string entry buffer
    88                                  
